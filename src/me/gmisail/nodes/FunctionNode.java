package me.gmisail.nodes;

import me.gmisail.Mox;
import me.gmisail.codegen.Generator;
import me.gmisail.core.Types;

import java.util.ArrayList;

public class FunctionNode extends Node {

    private String name;
    private String localName;
    private String returnType;

    private boolean isTemplated;
    private String templateType;

    public FunctionNode(String name, String type) {
        super();

        this.name = name;
        this.type = NodeTypes.FUNCTION;
        this.returnType = type;
        this.params = new ArrayList<ParameterNode>();
        this.isTemplated = false;
        this.templateType = "";
    }

    public void setLocalName(String localName) { this.localName = localName; }
    public String getLocalName() { return localName; }
    public String getName() { return name; }
    public String getReturnType() { return returnType; }

    public void makeTemplated(String templateType) {
        this.isTemplated = true;

        setTemplateType(templateType);
    }

    public boolean isTemplated() {
        return isTemplated;
    }

    public void setTemplateType(String templateType){ this.templateType = templateType; }
    public String getTemplateType() { return templateType; }

    @Override
    public String code() {

        /*
        *   Okay, so here is the lowdown:
        *
        *   First, we are going to check if it is a ~templated~ function. In which case, we will generate the
        *   function as a macro, as opposed to a normal function. Before the function CALL however, we will need to
        *   #define TYPE WhateverType to ensure that the compiler is using the correct type.
        *
        *   If it is not, then we will check if it is a class function. If so, generate as normal. Same for normal functions.
        * */

        ClassNode parent = (ClassNode) Mox.state.getProgram().getParentNodeOfType(NodeTypes.CLASS);
        boolean parentTemplated = false;

        if(parent != null) {
            parentTemplated = parent.isTemplated();

            /*
            *   class Array<T> ...
            *
            *   function get(i : int) -> T
            *
            *   end
            *
            *   This will be true when the return type is a placeholder for the template class.
            *
            *   Macro is formatted in accordance to this web-page: http://arnold.uthar.net/index.php?n=Work.TemplatesC
            *   as well as here: http://blog.pkh.me/p/w20-templating-in-c.html
            *
            *   On a function call, have:
            *
            *   function get(i : int) -> T
            *       return self.buffer[i]
            *   end
            *
            *   ... which becomes ...
            *
            *   #define DECLARE_FUNC_classname_functionname(T) \
            *   static ##T get_##T(Vector* v, int i) \
            *       return v->buffer[i];             \
            *   }
            *
            *   In practice:
            *
            *   var a : Array<int> = new Array<int>(5)
            *   a.set(0, 10)
            *   printf("%i", a.get(0))
            *
            *   ... becomes ...
            *
            *   Array* a = Array_alloc(5);
            *   DECLARE_FUNC_Array_set(int)      <---- generated by Mox compiler
            *   Array_set_int(a, 0, 10);
            *   DECLARE_FUNC_Array_get(int)      <---- generated by Mox compiler
            *   printf("%i", Array_get_int(a, 0));
            *
            *
            *   UPDATE:
            *
            *   Store the function as a template of sorts, so that if needed,
            *   we can generate a function of said type. Or stick to macros if
            *   they are useful.
            *
            * */

            
        }

        String output = "";

        if(isTemplated) {
            output += "#define declare_" + name + "(" + templateType + ") \\ \n";
        }

        output += returnType + " " + name + "(";

        for(int i = 0; i < this.params.size(); i++) {
            if(i > 0) output += ", ";

            String paramType = this.params.get(i).type;

            if(paramType.equals(templateType)) {
                paramType = templateType;
            }

            if(!this.params.get(i).name.equals("self") && !Types.exists(this.params.get(i).type)) {
                /*
                *   if the input is a pointer, then dereference and add another asterisk. It is kinda
                *   hacky but gets the correct result. As far as I know at least...
                * */
                if(!isTemplated)
                    output += Generator.dereference(paramType) + "* " + this.params.get(i).name;
                else
                    output += paramType + " " + this.params.get(i).name;

            } else {
                if(this.params.get(i).type.equals("any")) {
                    output += "void*";
                } else {
                    output += paramType;
                }

                output += " " + this.params.get(i).name;
            }
        }

        output += ")";

        if(isTemplated)
            output += " \\";

        return output;
    }
}
